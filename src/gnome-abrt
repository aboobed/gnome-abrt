#!/usr/bin/env python
# coding=UTF-8

## Copyright (C) 2012 ABRT team <abrt-devel-list@redhat.com>
## Copyright (C) 2001-2005 Red Hat, Inc.

## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335  USA

import os
import sys
import logging
import signal
from argparse import ArgumentParser

# pygobject
from gi.repository import Gtk
from gi.repository import GLib
from gi.repository import Gio
from gi.repository import GObject

# gnome-abrt
import gnome_abrt
from gnome_abrt.l10n import _
from gnome_abrt.wrappers import show_events_list_dialog
from gnome_abrt.config import get_configuration

# dbus
import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop

GNOME_ABRT_APPLICATION_ID='org.freedesktop.GnomeAbrt'
GNOME_ABRT_INTERFACE='org.freedesktop.GnomeAbrt'
GNOME_ABRT_OBJECT_PATH='/org/freedesktop/GnomeAbrt'


# because of https://bugzilla.gnome.org/show_bug.cgi?id=682331
class GtkApplicationDBUSImpl(object):
    class Service(dbus.service.Object):
        def __init__(self, bus, bus_name, application):
            bus_name = dbus.service.BusName(bus_name, bus)
            dbus.service.Object.__init__(self, bus_name, GNOME_ABRT_OBJECT_PATH)
            self._app = application

        @dbus.service.method(dbus_interface=GNOME_ABRT_INTERFACE,
                             in_signature='as', out_signature='')
        def command_line(self, argv):
            class Arguments(object):
                def __init__(self, argv):
                    self._argv = argv

                def get_arguments(self):
                    return self._argv

            self._app._parse_command_line(self, Arguments([str(a) for a in argv]))


    def __init__(self, bus_name, application):
        self._app = application
        self.mainloop = DBusGMainLoop()
        bus = dbus.SessionBus(mainloop = self.mainloop)

        self._primary_obj = None
        self._primary_iface = None
        self._service = None

        if bus.name_has_owner(bus_name):
            self._primary_obj = bus.get_object(bus_name, GNOME_ABRT_OBJECT_PATH)
        else:
            self._service = GtkApplicationDBUSImpl.Service(bus, bus_name, self._app)

    def is_remote(self):
        return not not self._primary_obj

    def send_command_line(self, argv):
        if not self.is_remote():
            raise RuntimeError("Can't send command-line message because instance is not a remote application")

        if not self._primary_iface:
            self._primary_iface = dbus.Interface(self._primary_obj, GNOME_ABRT_INTERFACE)

        if len(argv) == 0:
            argv = dbus.Array([], signature='s')

        self._primary_iface.command_line(argv)


class OopsApplication(Gtk.Application):

    def __init__(self):
        super(OopsApplication, self).__init__()

        self._dbus_srv = GtkApplicationDBUSImpl(GNOME_ABRT_APPLICATION_ID, self)
        self.connect("command-line", self._parse_command_line)
        self.set_flags(Gio.ApplicationFlags.HANDLES_COMMAND_LINE)

    def _parse_command_line(self, sender, gcmdargs):
        argv = gcmdargs.get_arguments()

        if self._dbus_srv.is_remote():
            self._dbus_srv.send_command_line(argv)
            return 0

        if len(argv) > 0:
            conf = gnome_abrt.get_configuration()
            conf['problemid'] = argv[0]

        self.activate()
        return 0

    def do_activate(self):
        try:
            windows = self.get_windows()
            if windows:
                windows[0].present()
            else:
                conf = gnome_abrt.get_configuration()
                conf.add_option("all_problems", default_value=False)

                sources = []
                try:
                    sources.append(gnome_abrt.DBusProblemSource(self._dbus_srv.mainloop))
                except gnome_abrt.UnavailableSource as e:
                    logging.warning(e.message)

                # TODO : really ? move it somewhere else ...
                self.gcontext = GLib.main_context_default()
                try:
                    # TODO : pass the directory over command line
                    sources.append(gnome_abrt.DirectoryProblemSource(os.path.join(GLib.get_user_cache_dir(), "abrt/spool"), context=self.gcontext))
                except gnome_abrt.UnavailableSource as e:
                    logging.warning(e.message)

                if len(sources) == 0:
                    raise gnome_abrt.UnavailableSource("No available problem source.")

                self.source = gnome_abrt.MultipleSources(*sources)

                main_window = gnome_abrt.OopsWindow(self, self.source, gnome_abrt.Controller(self.source))
                main_window.show_all()
                self.add_window (main_window)
        except Exception as e:
            logging.exception(e.message)
            sys.exit(1)

    def do_startup(self):
        Gtk.Application.do_startup(self)

        menu = Gio.Menu()
        menu.append(_("_Preferences"), "app.preferences")
        menu.append(_("_About"), "app.about")
        menu.append(_("_Quit"), "app.quit")

        action = Gio.SimpleAction.new("preferences", None)
        action.connect("activate", self.on_action_prefrences);
        self.add_action(action);

        action = Gio.SimpleAction.new("about", None)
        action.connect("activate", self.on_action_about);
        self.add_action(action);

        action = Gio.SimpleAction.new("quit", None)
        action.connect("activate", self.on_action_quit);
        self.add_action(action);

        self.set_app_menu(menu)

    def on_action_prefrences(self, action, parameter):
        show_events_list_dialog(self.window)

    def on_action_about(self, action, parameter):
        dialog = Gtk.AboutDialog()
        dialog.set_icon_name("abrt");
        #dialog.set_version(VERSION);
        dialog.set_logo_icon_name("abrt");
        dialog.set_program_name("ABRT");
        dialog.set_copyright("Copyright Â© 2012 Red Hat, Inc");
        dialog.set_license(
                "This program is free software; you can redistribut"
                "e it and/or modify it under the terms of the GNU General Public License "
                "as published by the Free Software Foundation; either version 2 of the Li"
                "cense, or (at your option) any later version.\n\nThis program is distrib"
                "uted in the hope that it will be useful, but WITHOUT ANY WARRANTY; witho"
                "ut even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICU"
                "LAR PURPOSE.  See the GNU General Public License for more details.\n\nYo"
                "u should have received a copy of the GNU General Public License along wi"
                "th this program.  If not, see <http://www.gnu.org/licenses/>.");
        dialog.set_wrap_license(True);
        dialog.set_website("https://fedorahosted.org/abrt/");
        dialog.set_authors(["ABRT Team"]);
        #dialog.set_artists(artists);
        #dialog.set_translator_credits(_("translator-credits"));
        dialog.run()
        dialog.destroy()

    def on_action_quit(self, action, parameter):
        self.quit()


if __name__ == "__main__":
    signal.signal(signal.SIGINT, lambda signum, frame: sys.exit(1))

    gnome_abrt.init()

    CMDARGS = ArgumentParser(description = _('View and report application crashes'))
    CMDARGS.add_argument('-v', '--verbose', action='count', help=_('Be verbose'))
    CMDARGS.add_argument('-p', '--problem', help=_('Selected problem ID'))

    OPTIONS = CMDARGS.parse_args()

    if OPTIONS.verbose > 0:
        logging.getLogger().setLevel(logging.DEBUG)

    VARS = vars(OPTIONS)

    conf = get_configuration();
    # TODO : mark this option as hidden or something like that
    conf.add_option('problemid', default_value=None)

    app_cmdline = []
    if 'problem' in VARS:
        app_cmdline.append(VARS['problem'])

    exit_code = 1
    app = OopsApplication()
    try:
        exit_code = app.run(app_cmdline)
    except gnome_abrt.UnavailableSource as e:
        logging.error(e.message)

    sys.exit(exit_code)
